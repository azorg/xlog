// File: "doc.go"

/*
# X Logger

xlog - пакет реализует средства настройки *slog.Logger из
стандартного пакета "log/slog".

Пакет предоставляет возможности настройки логгера на основе структуры
конфигурации Conf. Имеется возможность управления уровнем логирования
в процессе выполнения программы. Встроена поддержка ротации файлов журналов.
Имеется возможность одновременно вывода журналов в канал (stdout/stderr),
в файл и в кастомный io.Writer при необходимости.
Добавлены дополнительные уровни логирования и для них установлены
метки (trace/notice/crit и т.п.). Имеется возможность выбора нескольких
хендлеров (Text/JSON). Есть опции управления видом журнала (в т.ч. форматом)
метки времени. Имеется возможность встраивания т.н. middleware для реализации
различных "хуков", "фильтров".

Есть возможность дополнения каждого сообщения в журнале специальным UUID
идентификатором содержащем монотонное время и контрольную сумму.

Используемый пакет "log/slog" включен в стандартную поставку Go начиная с
версии go1.21. Для использования с go1.20 может использоваться экспериментальный
пакет "golang.org/x/exp/slog".

Для реализации ротации файлов журналов используется пакет
"gopkg.in/natefinch/lumberjack.v2".

Заложены "мостики" единообразного поведения стандартного (legacy) логгера
из стандартного пакета "log" при работе через настроенный логгер slog.

В ряде случаев из всего пакета может быть полезна только одна функция
Setup(), которая на основе структуры конфигурации может настроить
нужное поведение глобального стандартного Go логгера "log" и
структурного логгера "slog".

Для настройки логгера логгера в перую очередь нужно обратить
внимание на фабрику New(), которая на основе заданной структуры конфигурации
возвращает указатель на структуру *Logger, которая в свою очередь содержит
указатель *slog.Logger, переменную slog.LevelVar и интерфейс Writer.
Последние два поля могут использоваться для изменения уровня логирования
во время выполнения программы и принудительной ротации логов соответственно.

Для создания логгеров с направлением журнала в заданный io.Writer
может использоваться фабрика NewWithWriter() или NewEx().

# Об архитектуре slog и xlog

Пакет slog предлагает "фронтенд" в виде структуры slog.Logger и ее методов
для формирования записей журнала и "бэкенд" в виде реализаций интерфейса
slog.Handler, который производит упаковку и отправку записей в заданный
io.Writer интерфейс. "Из коробки" slog предлагает несколько Handler'ов
(хендлер по умолчанию, slog.TextHandler и slog.JSONHandler).

Пакет xlog реализует расширение "фронтенда" в виде структуры xlog.Logger
и её методов. Реализованы дополнительные "сахарные" методы вроде Trace
или Debugf. В тоже время может использоваться "канонический фронтенд"
slog и использование "сахарных" методов не обязательно.

Пакет xlog обеспечивает гибкую настройку hanlder'ов c требуемыми обертками
и Middleware. Кроме форматов стандартного, Text и JSON hendler'а возможно
использование "человеческого" хендлера с простым текстовым выводом
(TintHandler) в т.ч. с ANSI подкраской вывода.

Дополнительно API xlog позволяет направлять журнал сразу по нескольким
направлениям (например в канал stderr и в заданный файл с ротацией).
Для подробностей см. интерфейс Writer и функции его формирования.
Имеется возможность отправки данных журнала по произвольному числу
направлений (см. MiltiWtiter).

Как при создании Handler'ов, так и при создании Logger'а может быть
задана цепочка Middleware, которая позволяет оборачивать функцию Handle
используемого Handler'а.

# Сценарий простейшего использования глобальных log/slog логгеров

	// Заполнить структуру конфигурации
	conf := xlog.Conf{
	  Level: "info",
	}

	// Обогатить структуру конфигурации переменными окружения
	xlog.Env(&conf)

	// Настроить все глобальные логгеры однотипно
	xlog.Setup(conf)

	// Обновить уровень логирования глобального логгера
	xlog.SetLevel(slog.LevelDebug)

	// Использовать глобальные логгеры log/slog
	slog.Debug("debug message", "value", 42)
	slog.Info("simple slog", "logLevel", GetLvl())
	slog.Error("error", "err", errors.New("some error"))
	log.Print("legacy logger")

# Сценарий использования xlog с обработкой переменных окружения и опций командной строки

	opt := xlog.NewOpt()  // создать набор опций (*xlog.Opt)
	conf := xlog.Conf{}   // подготовить структуру конфигурации xlog
	flag.Parse()          // обогатить opt из опций командной строки
	opt.UpdateConf(&conf) // обогатить conf опциями командной строки

	log := xlog.New(conf) // создать X-logger (*xlog.Logger)
	logger := log.Logger  // получить указатель на *slog.Logger

	log.Notice("Привет, XLog", "version", "1.0.0")
	mylog := logger.With("app", "helloworld")
	mylog.Info("application started")

	userLoginInfo := xlog.Fields{
	  "user_id":   123,
	  "ip":        "192.168.0.1",
	  "timestamp": time.Now(),
	}

	mylog.Debug("user login", "userLoginInfo", userLoginInfo)

# Преобразование xlog.Logger в slog.Logger и обратно

X-logger (`*xlog.Logger`) может быть преобразован в `*slog.Logger`
с помощью метода Slog() или просто доступа к полю Logger.

Обратное преобразование тоже возможно с помощью функции NewFromSlog().
При этом для логгера будут доступны "сахарные" методы типа
Debugf(), Notice(), Log(), но изменить уровень логирования "на лету"
с помощью Leveler'а или вызвать принудительную ротацию уже не
получиться.

# Перенаправление журналов в произвольные каналы

Функции-фабрики NewWithWriter() и NewEx() позволяют создавать логгеры, вывод
которых будет перенаправлен в заданный интерфейс io.Writer, что
позволит например отправлять журналы через какие-либо сокеты и FIFO, syslog.

# Интерфейс Writer

С помощью фабрики NewWriter может быть создан интерфейс Writer, который
используется при вызове функции NewEx(). В зависимости от аргументов в пакете
реализовано 12 возможных вариантов реализации интерфейса Writer. Вывод журнала
может производиться по нескольким направлениям:

 1. Канал/pipe (stdout/stderr)
 2. Файл журнала с ротацией или без
 3. Кастомный io.Writer заданный пользователем.

# Middleware

Имеется тип Middleware и тип методов MiddlewareFunc для их построения.
Middleware позволяет "оборачивать" (в т.ч. цепочками) методы Handle()
интерфейса slog.Handler.
Middleware позволяет реализовывать "хуки/обёртки" для дополнительного
управления журналированием. В частности middleware могут позволить записи
журалов с определенным свойствами направлять особым путем.
С использованием Middleware реализовано обогащение журналов дополнительными
атрибутами (goroutine, logId, logSum). Данный middleware добавляется в конец
цепочки.

# Режим "Multi handler"

С использованием Middleware можно создать логгер, который к примеру будет
пистать журнал в файл в формате JSON и на стандартный вывод в текстовом
формате одноврнеменно.
Для достижения данной возможности может использоваться middleware, создаваемая
с помощью функции NewMiddlewareMulti().

Ниже приведен пример соответствующего программного кода.
В примере для журнала выводимого на stdout и в файл используются
различные опции конфигурации.

	// Настройки журнала для вывода в JSON файл с ротацией
	conf := xlog.Conf{
	  Level:     "debug",
	  File:      "logs/itcagent.log",
	  FileMode:  "0640",
	  Format:    "json", // JSON handler
	  GoId:      true,
	  IdOn:      true,
	  SumOn:     true,
	  SumFull:   true,
	  SumAlone:  false,
	  TimeLocal: false, // UTC
	  Src:       true,
	  SrcPkg:    true,
	  SrcFunc:   true,
	  SrcFields: &xlog.Fields{
	    "id":   "xservice", // идентификатор сервиса
	    "host": "xservice.example.com",
	  },
	  Rotate: xlog.RotateConf{
	    Enable:     true,
	    MaxSize:    5,     // MB
	    MaxAge:     7,     // days
	    MaxBackups: 100,   // number
	    LocalTime:  false, // UTC
	    Compress:   true,
	  },
	}

	// Создать логгер (хендлер) для вывода в файл
	log := xlog.New(conf)

	// Настройки "человеческого" журнала для вывода на stdout
	conf = xlog.Conf{
	  Level:      "trace",
	  Pipe:       "stdout",
	  Format:     "tint", // tinted handler
	  GoId:       false,
	  IdOn:       true,
	  SumOn:      true,
	  TimeLocal:  true,    // Local time
	  TimeFormat: "space", // 2006-01-02_15.04.05.999999999
	  Src:        true,
	  SrcPkg:     false,
	  SrcFunc:    false,
	  Color:      true,
	}

	// Создать "Multi Handler" логгер (stdout/text + file/JSON)
	log = xlog.New(conf, xlog.NewMiddlewareMulti(log))

	log.Debug("Hello, Multi Handler!", "cnt", 1) // попадет в JSON файл и на stdout
	log.Trace("Hello, Multi Handler!", "cnt", 2) // попадет только на stdout
	log.Flood("Hello, Multi Handler!", "cnt", 3) // будет пропущено

# Fields, FieldsProvider

Имеется простой биндинг для наполнения записей журнала из карты ключ/значение.
Это исключительно косметическая возможность. Утилита go fmt хорошо форматирует
литералы для карт, что благотворно влияет на читаемость программного кода.
Имеются фнкции и методы логгера WithFields, которые аналогичны методам
With и WithAttrs, но должны получать на вход интерфейсы FieldsProvider.

Пример использование Fields:

	xlog.Error(
	  "error with fields (Args)",
	  "err", errors.New("error"),
	  slog.Group(
	    "header",
	    xlog.Fields{
	      "type": "magic",
	      "size": 16384,
	    }.Args()...))

	log := xlog.WithAttrs(xlog.Fields{
	  "application": "testAplication",
	  "version":     "1.2.3",
	}.Attrs())

	log.Notice("notice with fields (Args)", "someFlag", true)

	log.Debug(
	  "debug with fields",
	  xlog.Fields{
	   "superValue": 123,
	   "now":        time.Now(),
	   "str":        "some string",
	   "pi":         3.1415926,
	  }.Args()...)

	logXY := log.WithFields(xlog.Fields{
		"x": 1,
		"y": 2,
	})

	logXY.Debug("vector", "z", 3)

# Утилита xlogscan

Утилита предназначена для проверки целостности файлов журналов в JSON формате
с помощью сверки контрольных сумм (logSum или LogId).

Утилита основана на работе функции ChecksumVerify(), которая возвращает
структуру типа ChecksumRes по результатам обработки каждой записи.
Каждая запись должна быть обработана JSON декодером перед передачей
на вход функции ChecksumVerify.

# С чего начать?

 1. Ознакомьтесь со структурой конфигурации Conf
 2. Ознакомьтесь со структурой Logger
 3. Ознакомьтесь с интерфейсом Writer
 4. Ознакомьтесь с конструкторами для структуры Logger
 5. Ознакомьтесь с методами структуры Logger
 6. Ознакомиться с устройством Middleware

В пакете есть функции глобального логгера эквивалентные методам
структуры Logger (например Infof() или Fatal())
*/
package xlog

// EOF: "doc.go"
