# Стандартные идентификаторы атрибутов xlog

Дата модификации: 2025.09.07

## Метка времени (обязательное поле)

Идентификатор: `time`.

Были предложен timestamp, но time наиболее принятый идентификатор
для logfmt/JSON форматов логов.

Формат: RFC3339Milli или RFC3339Micro.

Есть впечатление, что для JSON логов стандартная метка - это RFC3339Nano
Но мы приняли иное Решение.

В xlog по умолчанию миллисекунды, но можно расширить
до микросекунд (если TimeMicro=true).
Нужны ли нам наносекунды? - Решили, что - НЕТ.

Часовой пояс: По умолчанию UTC (т.е. с "Z").

По опции `TimeLocal=true` (`LOG_TIME_LOCAL=1` или `-log-time-local=yes`) можно
переключиться на локальное время, но по умолчанию принято именно UTC!

## Уровень логирования (обязательное поле)

Идентификатор: `level`

Формат: строка вида (пример):

- FLOOD - для совершенно избыточных сообщений (прям с выдачей PEM'ок и т.п.)
- TRACE - трассировка всех вызовов (syslog)
- DEBUG - уровень отладки (стандартный)
- INFO - нормальный уровень информационных (редких/однократных) сообщений
- NOTICE - дополнительные события, на которые нужно обратить внимание
- WARN - предупреждение (ошибка смежной системы)
- ERROR - стандартная ошибка (нет доступа к файлу, разрыв соединения и т.п.)
- CRIT - критическая ошибка (очень неожиданная и серьезная ошибка)
- ALERT - ошибка (syslog)
- EMERG - критическая шибка (syslog)
- FATAL - критическая ошибка после которой сервис завершает работу (Golang)

Не все уровни являются обязательными.
Парсер может допускать строки в нижнем регистре,
но принято в верхнем.
Возможно выдача просто десятичного числа (0 - INFO).
Возможно гибридные строки (в go) вида `ERROR+2`.

## Информация об исходных текстах

Идентификатор: `source`

Внимание! Это стандартный идентификатор для slog.JSONHandler/TextHandler.
slog по умолчанию использует поля file/funtion/line.
В JSON представлении обычно это выглядит так:
```json
"source":{"file":"service.go","function":"someFunc","line":1314}
```

Поля file, function - текстовые (имя файла и имя функции/метода).
Поле line - целое число (номер строки).

Допускается возможность обогащения данной структуры дополнительными полями,
такими как (пример):
 - hostname (имя хоста/FQDN)
 - version (версия приложения)
 - ip (IP адреса - массив)
 - type (тип сервиса)
 - id (уникальный идентификатор сервиса или его имя)

Из имени файла расширение `.go` исключается по умолчанию
(особенность пакета xlog, но можно включить задав `SrcExt=true`).
По умолчанию выводится только имя файла, но можно добавить
вывод каталога (пакета) путем задания `SrcPkg=true`.
По умолчанию slog.JSONHandler выводит полый путь файлов, что строго
говоря, избыточно.

## Сообщение (обязательное поле)

Идентификатор: `msg`

Формат: текстовая строка.

Главная суть сообщения в журнале.

## Идентификатор горутины (не обязательное поле)

Идентификатор: `goroutine`

Формат: целое число.

Может опускаться для "главное горутины" (0 или 1).
По умолчанию опция отключена (см. поле GoId в структуре конфигурации).

## Уникальный идентификатор сообщения (не обязательное поле)

Идентификатор: `logId`

Формат: UUID в виде стандартной HEX строки.

Содержимое: UUID (см. ниже).

Последние (младшие) два байта могут подменяется контрольной суммой.
Такое решени с маленькой вероятностью может нарушать монотонность
UIUD идентификатор.

## Открепленная контрольная сумма (не обязательное поле)

Идентификатор: `logSum`

Формат: строка из двух HEX символов (fmt.Sprintf("%04x", logSum) в нижнем регистре.

По умолчанию контрольная сумма размещается внутри `logId`.
Но по опции `SumAlone=true` в конфигурационном файле можно
"открепить" контрольную сумму для отладки ИЛИ для того, чтоб
получить "чистый" UUID идентификатор в качестве `logId`.

Контрольная сумма считается специальным образом так,
чтоб перестановка полей JSON структур не приводила к её изменению.
Способ ее подсчёта описан отдельно и строго говоря это "ноу-хау" компании.
Возможен подсчет суммы с учётом контрольной суммы предыдущего
сообщения (если включена опция `SumChain=true`).

Сумма считается с использованием CRC16.

CRC16 вычисляется по следующим данным в текстовом представлении:

 - time (RFC3339Milli или RFC3339Micro как в журнале)
 - level (как строка типа ERROR, WARN и т.п.)
 - msg (как строка)
 - logId (старшие 14 байт)
 - err, если есть

В случае использования опции SumFull контрольная сумма вычисляется по всем атрибутам.

Тип CRC16 (полином, начальное значение, ...): CRC-16/XMODEM
```
	Name:   "CRC-16/XMODEM"
	Poly:   0x1021
	Init:   0x0000
	RefIn:  false
	RefOut: false
	XorOut: 0x0000
	Check:  0x31C3
```

## Стандартная ошибка (не обязательное поле)

Идентификатор: `err`

Формат: строка.

Используется для сообщения ошибок (обычно уровня info/warn/crit/emerg/fatal).
Если в сообщении передается несколько ошибок, то может использоваться
`err1`, `err2` или `errSocket`, `errIO`  и т.п.

Типичный вывод Go ошибки в журнал:
```go
  if err != nil {
    log.Error("some error", "err", err)
  }
```

## Иные идентификаторы, группы, структуры

Что касается других полей и групп (event, system, user и т.п.)
считаю, что сам код "логгера" (или обёртки) не должен "о них знать".
Этими "статическими" данными журнал может быть обогащен путем создания
т.н. "sublogger'ов". Для slog/xlog в Go это делается с помощью метода
With() и т.п.

